"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.race = exports.provideContext = exports.never = exports.makeWithEntry = exports.makeBatched = exports.make = exports.fromFunctionEffect = exports.fromFunctionBatched = exports.fromFunction = exports.eitherWith = exports.contramapContext = exports.batchN = exports.around = void 0;
var Chunk = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Chunk"));
var Debug = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Debug"));
var RA = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/ReadonlyArray"));
var Cause = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Cause"));
var Effect = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/Effect"));
var core = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/io/internal_effect_untraced/core"));
var _effect = /*#__PURE__*/require("@effect/io/internal_effect_untraced/effect");
var _request = /*#__PURE__*/require("@effect/io/internal_effect_untraced/request");
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/** @internal */
const make = /*#__PURE__*/Debug.untracedMethod(restore => runAll => new core.RequestResolverImpl(requests => restore(runAll)(requests.map(_ => _.map(_ => _.request)))));
/** @internal */
exports.make = make;
const makeWithEntry = /*#__PURE__*/Debug.untracedMethod(restore => runAll => new core.RequestResolverImpl(requests => restore(runAll)(requests)));
/** @internal */
exports.makeWithEntry = makeWithEntry;
const makeBatched = /*#__PURE__*/Debug.untracedMethod(restore => run => new core.RequestResolverImpl(requests => Effect.forEachDiscard(requests, block => restore(run)(block.filter(_ => !_.state.completed).map(_ => _.request)))));
/** @internal */
exports.makeBatched = makeBatched;
const around = /*#__PURE__*/Debug.untracedDual(3, restore => (self, before, after) => new core.RequestResolverImpl(requests => Effect.acquireUseRelease(before, () => restore(self.runAll)(requests), after), Chunk.make("Around", self, before, after)));
/** @internal */
exports.around = around;
const batchN = /*#__PURE__*/Debug.untracedDual(2, restore => (self, n) => new core.RequestResolverImpl(requests => {
  return n < 1 ? Effect.die(Cause.IllegalArgumentException("RequestResolver.batchN: n must be at least 1")) : restore(self.runAll)(Array.from(Chunk.map(Chunk.reduce(Chunk.unsafeFromArray(requests), Chunk.empty(), (acc, chunk) => Chunk.concat(acc, Chunk.chunksOf(Chunk.unsafeFromArray(chunk), n))), chunk => Array.from(chunk))));
}, Chunk.make("BatchN", self, n)));
/** @internal */
exports.batchN = batchN;
const contramapContext = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => new core.RequestResolverImpl(requests => Effect.contramapContext(restore(self.runAll)(requests), context => restore(f)(context)), Chunk.make("ContramapContext", self, f)));
/** @internal */
exports.contramapContext = contramapContext;
const eitherWith = /*#__PURE__*/Debug.untracedDual(3, restore => (self, that, f) => new core.RequestResolverImpl(batch => Effect.forEach(batch, requests => {
  const [as, bs] = RA.partitionMap(restore(f))(requests);
  return Effect.zipWithPar(restore(self.runAll)(Array.of(as)), restore(that.runAll)(Array.of(bs)), () => void 0);
}), Chunk.make("EitherWith", self, that, f)));
/** @internal */
exports.eitherWith = eitherWith;
const fromFunction = /*#__PURE__*/Debug.untracedMethod(restore => f => makeBatched(requests => Effect.forEachDiscard(requests, request => (0, _request.complete)(request, core.exitSucceed(restore(f)(request))))).identified("FromFunction", f));
/** @internal */
exports.fromFunction = fromFunction;
const fromFunctionBatched = /*#__PURE__*/Debug.untracedMethod(restore => f => makeBatched(as => (0, _effect.forEachWithIndex)(restore(f)(as), (res, i) => (0, _request.complete)(as[i], core.exitSucceed(res)))).identified("FromFunctionBatched", f));
/** @internal */
exports.fromFunctionBatched = fromFunctionBatched;
const fromFunctionEffect = /*#__PURE__*/Debug.untracedMethod(restore => f => makeBatched(requests => Effect.forEachParDiscard(requests, a => Effect.flatMap(Effect.exit(restore(f)(a)), e => (0, _request.complete)(a, e)))).identified("FromFunctionEffect", f));
/** @internal */
exports.fromFunctionEffect = fromFunctionEffect;
const never = /*#__PURE__*/Debug.untracedMethod(() => _ => make(() => Effect.never()).identified("Never"));
/** @internal */
exports.never = never;
const provideContext = /*#__PURE__*/Debug.untracedDual(2, () => (self, context) => contramapContext(self, _ => context).identified("ProvideContext", self, context));
/** @internal */
exports.provideContext = provideContext;
const race = /*#__PURE__*/Debug.untracedDual(2, restore => (self, that) => new core.RequestResolverImpl(requests => Effect.race(restore(self.runAll)(requests), restore(that.runAll)(requests))).identified("Race", self, that));
exports.race = race;
//# sourceMappingURL=dataSource.js.map